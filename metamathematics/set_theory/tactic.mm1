--基本tactic--
do{
    --|恒等函数(id x)：返回x。
    (def (id x) x)
    --|忽略函数(ignore x_1 x_2 ... x_n)：接受任意参数且不做任何处理，返回#undef。
    (def (ignore . _))
    --|调试打印函数(dbg x)或(dbg x y)：若调用形式为(dbg x)，则打印x并返回x；若调用形式为(dbg x y)，则打印x: y并返回y。
    (def dbg @ match-fn* [(x) (print x) x]
    [(x y) (display @ string-append (->string x) ": " (->string y)) y])
    --|左折叠函数(foldl l z s)：l是列表，z是项，(s x y)是一个接收两个参数的函数。返回(s (··· (s (s z l1) l2)···) ln)。
    (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
    --|右折叠函数(foldr l z s)：l是列表，z是项，(s x y)是一个接收两个参数的函数。返回(s l1 (s l2 (··· (s ln z)···)))。
    (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
    --|区间函数(range a b)：a,b是自然数。返回一个(a a+1 a+2 ··· b-1)的列表。
    (def (range a b) (if {a = b} () (cons a (range {a + 1} b))))
    --|for循环函数(for a b f)：a,b是自然数，(f x)是一个接受一个自然数为参数的函数。执行(f a),(f a+1),(f a+2),···,(f b-1)并返回#undef。
    (def (for a b f) (if {a = b} #undef (begin (f a) (for {a + 1} b f))))
    --|末位函数(last l)：l是一个列表，返回列表l中的最后一个项。
    (def last (match-fn [(a) a] [(_ . l) (last l)]))
    --|末位分离函数(split-last l)：l是一个列表，将列表l中的最后一个项移至最前端并返回。
    (def split-last @ match-fn
    [(and (_) l) l]
    [(a . l) @ match (split-last l) @ (r . l2) '(,r ,a . ,l2)]
    [() ()])
    --|连接函数(append . ls)：接受任意数量的列表参数，将这些列表连接起来并返回。
    (def (append . ls) @ foldr ls () @ fn (l l2) @ foldr l l2 cons)
    --|翻转函数(rev l)：l是一个列表，返回l的翻转（将l的左右反过来）。
    (def (rev l) @ foldl l () (fn (l a) (cons a l)))
    --|长度函数(len l)：l是一个列表，返回l的长度（项的个数）。
    (def (len l) @ foldl l 0 (fn (n _) {n + 1}))
    --|过滤函数(filter l p)：l是一个列表，(p x)是一个有一个参数的函数。将l中的项作为p的参数执行，筛选出返回值为#t的项并打包成列表返回。
    (def (filter l p) @ foldl l () @ fn (l2 x) @ if (p x) (cons x l2) l2)
    --|重复函数(repeat a n)：返回一个含有n个a的列表(a a ··· a)。
    (def (repeat a n) (if {n = 0} () (cons a (repeat a {n - 1}))))
    --|迭代函数(iterate n a f)：返回(f (f ··· (f a)))，其中f被执行n次。
    (def (iterate n a f) (if {n = 0} a (f (iterate {n - 1} a f))))
    --|判断列表是否为空函数(empty l)：如果l是个空列表()则返回#t，否则返回#f。
    (def empty? @ match-fn ['() #t] [_ #f])
    --|查询生成函数(find l)：l是一个映射（形如((k1 v1) (k2 v2) ··· (kn vn))的列表），返回一个函数，该函数接收一个参数k，寻找l中k对应的v，找不到则返回#undef。
    (def (find l) @ match l
    [((k v) . l) (def f (find l)) @ fn (a) @ if {k == a} v (f a)]
    [() @ fn (a)])
    --|阻止繁饰函数(verb e)：给表达式e加上:verb标签并返回（保持错误等输出信息位置与e相同）。:verb标签用于告诉验证器不需要对其进行繁饰。
    (def (verb e) (copy-span e (list ':verb e)))
    --|当前结果函数(result)：返回当前目标。
    (def (result) (hd (get-goals)))
    --|当前目标函数(target)：返回当前目标的表达式。
    (def (target) (goal-type (result)))
    --|检查结果函数(inspect-result f)：(f)是一个没有参数的策略。打印当前目标后执行策略(f)。
    (def (inspect-result f) (def g (result)) (refine (f)) (display @ pp g))
    --|等待函数(later)：会将当前的第一个目标移动到最后一个目标（即先不解决）。
    (def (later) @ match (get-goals)
    [(g . gs) (apply set-goals @ append gs @ list g)])
    --|元变量类型函数(mvar-sort m)：m是一个元变量，返回m的类型。
    (def mvar-sort @ match-fn @ (mvar s _) s)
    --|报告函数(report a)：a是一个公式。打印当前目标后试图用a匹配证明当前目标。
    (def (report a) (def g (result)) (refine a) (print g))
    --|原子映射创建函数(atom-map (k1 v1) (k2 v2) ··· (kn vn))：创建一个内容为((k1 v1) (k2 v2) ··· (kn vn))的映射，其中k1,k2,···,kn必须是原子项。
    (def (atom-map . xs) (get! @ apply atom-map! xs))
    --|原子查询生成函数(lookup-fn xs)：xs是一个创建一个内容为((k1 v1) (k2 v2) ··· (kn vn))的映射，其中k1,k2,···,kn必须是原子项。返回该映射的查询函数。
    (def (lookup-fn xs) (def m (apply atom-map xs)) (fn k (apply lookup m k)))
    --|原子名连接函数(atom-app x1 x2 ··· xn)：x1,x2,···,xn都是原子项。函数返回一个以将x1,x2,···,xn的名字连接起来为名字的原子项
    (def (atom-app . xs) (string->atom (apply string-append (map ->string xs))))
    --|矩阵转置函数(transpose xs)或(transpose n xs)：xs是一个a×b的矩阵（一个长度为a的列表，该列表的每一个项为长度为b的列表，形如((m11 m12 m13 ···) (m21 m22 m23 ···) ···)）。若调用形式为(transpose xs)，则直接返回xs的转置（形如((m11 m21 m31 ···) (m12 m22 m32 ···) ···)）；若调用形式为(transpose n xs)，则当xs为空的时候返回一个长度为n的列表，其中每一项都是空（形如(() () () ···)）。
    (def transpose @ match-fn*
    [(xs) (apply map list xs)]
    [(n xs) (if (null? xs) (repeat () n) (apply map list xs))])
    --|连接函数(join x1 x2 ··· xn)：将列表x1,x2,···,xn连接起来。
    (def (join . xs) (apply append xs))
    --|右map函数(rmap x1 x2 ··· xn f)：相当于执行(map f x1 x2 ··· xn)。
    (def (rmap . args) (apply map (split-last args)))
    --|扫描函数(scan x1 x2 ··· xn f)：执行(map f x1 x2 ··· xn)并不返回任何值（用f扫描x1,x2,···,xn）。
    (def (scan . args) (apply rmap args) #undef)
    --|检查未定义函数(undef? x)：如果x被定义，则返回#t，否则返回#f。
    (def (undef? x) (not (def? x)))
    --|错误报告函数(error-at)：在sp处报告错误msg。
    (def (error-at sp msg) (report-at 'error sp msg))
    --|信息报告函数(info-at)：在sp处报告信息msg。
    (def (info-at sp msg) (report-at 'info sp msg))
    --|目标创建函数(goal! ty)或(goal! pos ty)：当调用形式为(goal! ty)时，创建目标ty并返回其引用。当调用形式为(goal! pos ty)时，创建目标ty，并将pos位置信息转移到目标上并返回其引用。
    (def goal! @ match-fn*
    [(ty) (ref! (goal ty))]
    [(pos ty) (ref! (copy-span pos (goal ty)))])
    --|获取证明函数(get-proof x)：x是一个定理，返回x的证明。
    (def (get-proof x) @ match (get-decl x)
    [('theorem _ _ _ _ _ pf) (hd @ tl @ pf)]
    [_ (error "not a theorem")])
    --|打印证明函数(pp-proof x)：x是一个定理，打印x的证明。
    (def (pp-proof x) (display @ pp @ get-proof x))

    --|符合策略(exact e)：将定理e尝试与第一个目标匹配，如果匹配则解决该目标。
    (def (exact e) (refine (verb e)))
    --|交换策略(swap)：将当前目标移动至目标队列末尾。
    (def (swap) @ match (get-goals) [(x . y) (apply set-goals @ append y @ list x)])
    --|满足策略(suffices h)或(suffices h e)或(suffices h p)或(suffices h e p)：创建一个新假设h，e是h的表达式(可选)，p是h的证明(可选)，如果不提供证明则在目标队列中添加h至末尾。
    (def suffices @ match-fn*
    [(h) (have h _) (swap)]
    [xs (apply have xs) (swap)])

    --|公理组
    (def axiom-sets (atom-map!))
    --|添加公理组函数(add-axiom-set! x doc xs)：x是一个原子表示该公理组的名字，doc是一个字符串是该公里组的描述，xs是一个列表，内含该公理组的公理。
    (def (add-axiom-set! x doc xs) (insert! axiom-sets x (cons doc xs)))

    --| This utility will take a verbatim proof and "unelaborate" it into a refine script
    --| using ! on every step. This is useful to get `refine` to re-typecheck a term when
    --| testing tactics which produce verbatim proofs.
    (def unelab @ letrec (
    [(args bs xs)
        @ if (null? bs) (map rec xs)
        @ cons (hd xs) @ args (tl bs) (tl xs)]
    [rec @ match-fn
        [(':conv tgt _ p) '{,(rec p) : ,tgt}]
        [(f . xs)
        (cons '! f @ args (nth 2 @ get-decl f) xs)]
        [e e]])
    rec)

    --| `(named pf)` wraps a proof script `pf`, runs it, then gathers all
    --| unassigned metavariables and assigns them to dummies.
    --| `(named x1 ... xn pf)` is the same but names the first `n` variables `x1,...,xn`.
    --| This is commonly used for proofs where we don't care to name the
    --| dummy variables.
    (def named
    (def (assign-mvar m x) @ match x ['_] [_ (set! m (dummy! x (mvar-sort m)))])
    @ match-fn*
        [((? atom? d) es) (refine es) (scan (get-mvars) (list d) assign-mvar)]
        [(ds es) (refine es) (scan (get-mvars) ds assign-mvar)]
        [(es) (refine es)
        (def n (ref! 1))
        (scan (get-mvars) @ fn (v)
            (assign-mvar v (atom-app "a" n)) (set! n {n + 1}))
        (if {n = 1} (display "unnecessary (named)"))])

    --| `(name-all x1 ... xn)` instantiates all metavariables in the current
    --| proof state. It is the same as `named` but it can be used in the middle of a
    --| proof instead of as a wrapper around a complete proof.
    (def (name-all . ds)
    (def (assign-mvar m x) @ match x ['_] [_ (set! m (dummy! x (mvar-sort m)))])
    (scan (get-mvars) ds assign-mvar))
};
